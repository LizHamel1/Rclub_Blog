[
  {
    "path": "posts/welcome/",
    "title": "Welcome to Rclub Blog",
    "description": "Welcome to the Rclub Blog.",
    "author": [
      {
        "name": "Vince Ramirez",
        "url": {}
      }
    ],
    "date": "2021-11-06",
    "categories": [],
    "contents": "\nIntroducing the R club Blog! A space for us to share everything R!\n\n\n\n",
    "preview": {},
    "last_modified": "2021-11-06T22:27:49-07:00",
    "input_file": "welcome.knit.md"
  },
  {
    "path": "posts/Writing Function R Club October 11/",
    "title": "R Club - Writing Functions",
    "description": "R Club",
    "author": [
      {
        "name": "Bob Pellegrino",
        "url": {}
      }
    ],
    "date": "2021-11-06",
    "categories": [],
    "contents": "\nIntroduction\nWords from our sponsors\n\n“Writing good functions is a lifetime journey. Even after using R for many years I still learn new techniques and better ways of approaching old problems.” -Hadley Wickham\n\nOne of the best ways to improve your reach as a data scientist is to write functions. Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting. Writing a function has three big advantages over using copy-and-paste:\nYou can give a function an evocative name that makes your code easier to understand.\nAs requirements change, you only need to update code in one place, instead of many.\nYou eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).\nOther material\nSource Material for Functions\nhttps://r4ds.had.co.nz/functions.html ## Source Material on Purrr https://dcl-prog.stanford.edu/purrr-parallel.html ## More on Purrr https://r4ds.had.co.nz/iteration.html#the-map-functions ## Purrr Cheatsheat https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf\nCode\nPackages / Functions\nData Read\n\n\n# Create a table of 10 random number with a mean of zero (SD=1)\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf\n\n\n# A tibble: 10 x 4\n         a      b       c        d\n     <dbl>  <dbl>   <dbl>    <dbl>\n 1  0.397  -0.172  0.243  -1.34   \n 2 -1.65    0.572 -0.0604  0.385  \n 3  0.0109  0.147 -1.39   -0.726  \n 4 -1.07   -0.647 -0.255  -0.192  \n 5 -0.587   0.225 -1.76   -0.00239\n 6  1.13    1.53   0.803   0.272  \n 7 -1.54    0.297  0.600  -0.536  \n 8 -2.11    0.857  0.473  -0.825  \n 9  1.72    1.15  -0.156   0.216  \n10 -1.30   -0.831 -0.912   0.738  \n\nMaking a function\n\n\n# Rescale data to be between 0 and 1\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) / \n  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)) #look a mistake!\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) / \n  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) / \n  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\n\ndf # look at column B for the mistake from paste/copy\n\n\n# A tibble: 10 x 4\n       a     b     c     d\n   <dbl> <dbl> <dbl> <dbl>\n 1 0.654 0.432 0.782 0    \n 2 0.122 0.919 0.664 0.830\n 3 0.554 0.641 0.146 0.295\n 4 0.271 0.121 0.588 0.552\n 5 0.398 0.692 0     0.644\n 6 0.846 1.54  1     0.776\n 7 0.151 0.739 0.921 0.387\n 8 0     1.11  0.872 0.247\n 9 1     1.30  0.626 0.749\n10 0.212 0     0.332 1    \n\n# Reload OG dataframe\ndf <- get_data()\n\n# Ask yourself: Am I repeating code? Am I copy-pasting stuff?\n  ## YES! What am I repeating?\n  df$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n  \n  ## Reload OG dataframe\n  df <- get_data()\n\n  ## Rewrite the code using temporary variables with general names\n  x <- df$a\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n\n\n [1] 0.6134522 0.2724993 0.1575198 0.0000000 0.6985876 0.8486247\n [7] 1.0000000 0.2649639 0.1688003 0.3705756\n\n# Ask yourself: Is there still duplication?\n  ## YES! What am I repeating? [in this case, it's the range]\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n\n\n [1] 0.6134522 0.2724993 0.1575198 0.0000000 0.6985876 0.8486247\n [7] 1.0000000 0.2649639 0.1688003 0.3705756\n\n# Make the function\n  rescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n  }\n  \n  ## Check to make sure it works as expected\n  rescale01(c(0, 5, 10))\n\n\n[1] 0.0 0.5 1.0\n\n  ## Add to other customized functions and apply to dataframe\n  df$a <- rescale01(df$a)\n  df$b <- rescale01(df$b)\n  df$c <- rescale01(df$c)\n  df$d <- rescale01(df$d)\n\n\n\nThree things to making a function: 1. You need to pick a name for the function. Here I’ve used rescale01 because this function rescales a vector to lie between 0 and 1. + Function names should be verbs, and arguments should be nouns. + But if the function can be nouns if they represents known nouns (e.g. mean()) or properties of an object (e.g. coef()) + snake_case vs. camelCase - just be consistent + Avoid common function names as your local will have priority\nYou list the inputs, or arguments, to the function inside function. Here we have just one argument. If we had more the call would look like function(x, y, z).\nDefault value have a value set here. eg. rescale01(tmp, Finite = TRUE)\nThere are rules for some names: ++ x,y,z: vectors ++ df: dataframe ++ i,j: numberic indices (typically rows and columns respectively) ++ n: length, number of rows ++ p: number of columns\nYou place the code you have developed in body of the function, a { block that immediately follows function(…).\nstop() is useful to place in conditions if you only accept certain data; if(finite = FALSE){stop(“you can only have finite number here dude”)}\nreturn() another way to break out of a function and return a value\ninvisible() send an object, but don’t print it. Good for keeping things pipeable\nBetter functions\n\n\n# Reload OG dataframe\ndf <- get_data()\n\n# Make our rescale function even better - add default function argument and stop rule\nrescale01 <- function(x, finite=TRUE) {\n  # check for finite numbers in vector\n  if(finite == FALSE){\n    stop(\"you can only have finite number here dude!\")  \n  } \n  \n  #grab range (rng) to use min (rng[1]) and max (rng[2])\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n  \n}\n\n# Call function with attibute\nrescale01(df$a, finite = TRUE)\n\n\n [1] 1.0000000 0.4830712 0.2471926 0.0000000 0.7807315 0.9074545\n [7] 0.4280469 0.4185985 0.7871050 0.5057969\n\n# Pipe Dream - never break the pipe\nshow_missings <- function(df) {\n  n <- sum(is.na(df))\n  cat(\"Missing values: \", n, \"\\n\", sep = \"\")\n  \n  invisible(df)\n}\n\nshow_missings(mtcars) \n\n\nMissing values: 0\n\nmtcars %>% \n  show_missings() %>% \n  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% \n  show_missings() \n\n\nMissing values: 0\nMissing values: 18\n\npurrrFect functions\nFaster as they are written in C\nRun multiple columns within the pipe\n\n\n# What if I want to run all cols with a function?\ndf %>%\nmap(rescale01)\n\n\n\n$a\n [1] 1.0000000 0.4830712 0.2471926 0.0000000 0.7807315 0.9074545\n [7] 0.4280469 0.4185985 0.7871050 0.5057969\n\n$b\n [1] 0.00000000 0.41194793 0.38481369 0.03229157 0.39222853 0.94803398\n [7] 0.66793820 0.52663053 1.00000000 0.29863995\n\n$c\n [1] 0.6608461 0.6012546 0.3944278 1.0000000 0.6289678 0.8735957\n [7] 0.5255739 0.0000000 0.4887286 0.1933711\n\n$d\n [1] 0.09393033 0.60658005 0.57819965 0.82298791 0.37905302 0.00000000\n [7] 0.60423099 0.29118577 0.83895104 1.00000000\n\ndf %>%\n  map_dbl(mean)\n\n\n          a           b           c           d \n 0.04883398 -0.46369302  0.39199289  0.08693641 \n\n# But what about spitting out a vector instead of a list?\ndf %>%\n  map(rescale01) %>% str()\n\n\nList of 4\n $ a: num [1:10] 1 0.483 0.247 0 0.781 ...\n $ b: num [1:10] 0 0.4119 0.3848 0.0323 0.3922 ...\n $ c: num [1:10] 0.661 0.601 0.394 1 0.629 ...\n $ d: num [1:10] 0.0939 0.6066 0.5782 0.823 0.3791 ...\n\ndf %>%\n  modify(rescale01)\n\n\n# A tibble: 10 x 4\n       a      b     c      d\n   <dbl>  <dbl> <dbl>  <dbl>\n 1 1     0      0.661 0.0939\n 2 0.483 0.412  0.601 0.607 \n 3 0.247 0.385  0.394 0.578 \n 4 0     0.0323 1     0.823 \n 5 0.781 0.392  0.629 0.379 \n 6 0.907 0.948  0.874 0     \n 7 0.428 0.668  0.526 0.604 \n 8 0.419 0.527  0     0.291 \n 9 0.787 1      0.489 0.839 \n10 0.506 0.299  0.193 1     \n\n# What if I want to run a few cols with function?\ndf %>%\n  modify_at(c(\"a\", \"b\"), rescale01)\n\n\n# A tibble: 10 x 4\n       a      b       c      d\n   <dbl>  <dbl>   <dbl>  <dbl>\n 1 1     0       0.782  -1.68 \n 2 0.483 0.412   0.595   0.439\n 3 0.247 0.385  -0.0552  0.321\n 4 0     0.0323  1.85    1.33 \n 5 0.781 0.392   0.682  -0.502\n 6 0.907 0.948   1.45   -2.07 \n 7 0.428 0.668   0.357   0.429\n 8 0.419 0.527  -1.30   -0.866\n 9 0.787 1       0.241   1.40 \n10 0.506 0.299  -0.687   2.07 \n\ndf %>%\n  mutate_at(c(\"a\", \"b\"), ~ rescale01(.))\n\n\n# A tibble: 10 x 4\n       a      b       c      d\n   <dbl>  <dbl>   <dbl>  <dbl>\n 1 1     0       0.782  -1.68 \n 2 0.483 0.412   0.595   0.439\n 3 0.247 0.385  -0.0552  0.321\n 4 0     0.0323  1.85    1.33 \n 5 0.781 0.392   0.682  -0.502\n 6 0.907 0.948   1.45   -2.07 \n 7 0.428 0.668   0.357   0.429\n 8 0.419 0.527  -1.30   -0.866\n 9 0.787 1       0.241   1.40 \n10 0.506 0.299  -0.687   2.07 \n\ndf2 <- df\n\n\n# What if we're only going to run a function once? Answer: Anonymous functions\ndf %>%\n  modify(function(x) x+2)\n\n\n# A tibble: 10 x 4\n         a      b     c       d\n     <dbl>  <dbl> <dbl>   <dbl>\n 1  3.71   0.0551 2.78   0.318 \n 2  1.78   1.36   2.60   2.44  \n 3  0.895  1.28   1.94   2.32  \n 4 -0.0293 0.158  3.85   3.33  \n 5  2.89   1.30   2.68   1.50  \n 6  3.36   3.07   3.45  -0.0706\n 7  1.57   2.18   2.36   2.43  \n 8  1.54   1.73   0.705  1.13  \n 9  2.91   3.23   2.24   3.40  \n10  1.86   1.00   1.31   4.07  \n\n#shortcuts from purrr\ndf %>%\n  modify(~ . + 2)\n\n\n# A tibble: 10 x 4\n         a      b     c       d\n     <dbl>  <dbl> <dbl>   <dbl>\n 1  3.71   0.0551 2.78   0.318 \n 2  1.78   1.36   2.60   2.44  \n 3  0.895  1.28   1.94   2.32  \n 4 -0.0293 0.158  3.85   3.33  \n 5  2.89   1.30   2.68   1.50  \n 6  3.36   3.07   3.45  -0.0706\n 7  1.57   2.18   2.36   2.43  \n 8  1.54   1.73   0.705  1.13  \n 9  2.91   3.23   2.24   3.40  \n10  1.86   1.00   1.31   4.07  \n\n# So why are maps powerful with functions. Answer: pipe stuff\ndf %>% \n  mutate(e = c(rep(\"dude\", 5), rep(\"sweet\", 5))) %>%\n  split(.$e) %>%\n  map(~ lm(a ~ b, data =.)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n\n\n       dude       sweet \n0.001502336 0.627542932 \n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-11-06T22:29:32-07:00",
    "input_file": "purrrfect.knit.md"
  }
]
