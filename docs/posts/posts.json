[
  {
    "path": "posts/2024-05-16-uploading-to-the-r-club-blog1/",
    "title": "Uploading to the R club Blog",
    "description": "R Club on May 17th 2024: How to upload to the blog",
    "author": [
      {
        "name": "Vince Ramirez",
        "url": {}
      }
    ],
    "date": "2024-05-17",
    "categories": [],
    "contents": "\nA note: I am still learning the distill package and how distill blogs work. The current tutorial is to demonstrate the current workflow I have, and to motivate any R clubbers that want to help to maintain this blog.\nPurpose\nTo demonstrate how you can start contributing to the R club Blog and archive past R club presentations.\nWho?\nAnyone that takes part in R club.\nGetting Started\nIf you do not already use github/git, then please familiarize yourself with the basics. There are a number of GUI desktop applications that make using github very easy. Unfortunately I will, not cover using github in depth during today’s tutorial.\nTo contribute to the repository you will need to clone the github repository for the blog, and work within the project’s directories.\nI am assuming you are using R studio. To make everything run smoothly you should make Rmarkdown documents the standard for your R club presentations.\nFirst we will need to install the distill package.\ninstall.packages(\"distill\")\nThis will install the distill package which will allow your work to be formatted in a manner that can be implemented into the blog repository.\nThe easiest way to create a new blog post is to enter the following command in the directory of the blog\ndistill::create_post() \nThis will create a new post in the /_posts/ directory of the git repository.\ni created a new post for this R club (see below):\n\nYou can then add in your Rmarkdown file, or create a new Rmarkdown file into this repository.\nWhen beginning a new Rmarkdown file that you intend to have as a blog post, you should use the distill template.\n\nBe sure to format your YAML appropriately. An example is below\n\nYou can then run your Rmarkdown as usual.\nExample\nThe following data and example is based on analysis found at https://github.com/davestroud/BeerStudyhttps://github.com/davestroud/BeerStudy\nThe authors of this data set were interested in looking at the relationship between alcohol content (alcohol by volume or ABV) and bitterness of beer (IBU).\n\n\nlibrary(dplyr)\nlibrary(readr)\nlibrary(magrittr)\nlibrary(ggplot2)\nBeers<-read_csv(\"data/Beers.csv\", col_types = cols())\nBreweries<-read_csv(\"data/Breweries.csv\", col_types = cols())\n\nBeers<- Beers %>% rename(Brew_ID=\"Brewery_id\")\n\nBeer_data<-left_join(Beers,Breweries,by=\"Brew_ID\")\n\n\nFirst we can look at the distribution of IBU (International Bittering Units).\n\n\nBeer_data %>% ggplot(aes(x=IBU)) + geom_histogram()\n\n\n\nMost beers fall under 100 IBUs, although some do approach 120+. Many beers do not have IBUs listed.\nWe can also look at ABV (alcohol by volume)\n\n\nBeer_data %>% ggplot(aes(x=ABV)) + geom_histogram()\n\n\n\nMost beers are under 10% ABV.\nHow does ABV and IBU correlate?\n\n\nBeer_data %>% ggplot(aes(x=ABV,y=IBU)) + geom_point() + geom_smooth(method = \"lm\")\n\n\nBeer_data %>% ggplot(aes(x=ABV,y=IBU)) + geom_point() + geom_smooth(method = \"loess\")\n\n\n\nWhich State has the highest median ABV?\n\n\n\nWhich state has the highest median IBUs?\n\n\n\nLet’s Plot it on a Map\nHere I plot which state has the highest median ABV using.\n\n\nlibrary(usmap)\n\nMedian_ABV_IBU_State_<-Median_ABV_IBU_State %>% rename(state=\"State\")\n\nplot_usmap(data=Median_ABV_IBU_State_,values = \"Median ABV\") + scale_fill_gradient2(low=\"red\",mid=\"white\",high=\"blue\",midpoint = 0.053)\n\n\n\nAfter You Finish You Should Knit The Distill Article\nThis will create an html in our _post directory, and your post will be updated in the /docs/posts/ directory.\n\n\nChecking Your Distill HTML “index.html”\n\nFinal Steps\nYou need to push to github. We will need to figure out a work flow to have individuals push to the master branch when they have finished putting together their R markdown files. More to come soon.\n\n\n\n",
    "preview": "posts/2024-05-16-uploading-to-the-r-club-blog1/Example_files/figure-html5/unnamed-chunk-2-1.png",
    "last_modified": "2024-05-17T08:18:15-07:00",
    "input_file": "Example.knit.md"
  },
  {
    "path": "posts/R Club November 12/",
    "title": "Getting Started with ggplot2!",
    "description": "R-Club November 12 2021",
    "author": [
      {
        "name": "Vince Ramirez",
        "url": {}
      }
    ],
    "date": "2021-11-12",
    "categories": [],
    "contents": "\nIntroduction\nThe goal of today is to learn the basic structure of a ggplot2 command to create graphics. We will be working with the mtcars dataset which is already loaded into R.\nA quick view of this data can be done using the glimpse, str, or head functions. Take your pick!\n\n\nstr(mtcars)\n\n\n'data.frame':   32 obs. of  11 variables:\n $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n $ disp: num  160 160 108 258 360 ...\n $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n $ qsec: num  16.5 17 18.6 19.4 17 ...\n $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n\n\n\nhead(mtcars)\n\n\n                   mpg cyl disp  hp drat    wt  qsec vs am gear carb\nMazda RX4         21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag     21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710        22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive    21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\nValiant           18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\n\n\n\nglimpse(mtcars)\n\n\nRows: 32\nColumns: 11\n$ mpg  <dbl> 21.0, 21.0, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 1…\n$ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6, 6, 8, 8, 8, 8, 8, 8, 4, 4…\n$ disp <dbl> 160.0, 160.0, 108.0, 258.0, 360.0, 225.0, 360.0, 146.7,…\n$ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123, 123, 180…\n$ drat <dbl> 3.90, 3.90, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3…\n$ wt   <dbl> 2.620, 2.875, 2.320, 3.215, 3.440, 3.460, 3.570, 3.190,…\n$ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20.00,…\n$ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1…\n$ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1…\n$ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 4, 4…\n$ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4, 4, 3, 3, 3, 4, 4, 4, 1, 2…\n\nPlotting Using base-R\nWe can use the base functions in R to make plots of these data. R itself has very powerful graphic capabilities, and for many this works just fine.\nA simple plot may want to look at the relationship between horsepower and miles per gallon. This is easy visualized below\n\n\nplot(hp~mpg,data = mtcars,ylab=\"horsepower\",xlab=\"miles per gallon\")\n\n\n\n\nAn alternative method is to use the package ggplot2 in order to create your visuals.\nggplot2: A primer\nggplot2 is a powerful graphics library in R which is part of the larger tidyverse. It is praised for the ability to create powerful and highly customizable visuals with relatively simple commands.\nThese commands follow a very generic structure which is defined as follows:\nggplot2(data= x, mappings=aes())+ geom_function()\nor\nggplot2(data) + geom_function(mapping=aes())\nWhere aes() is the aesthetics in your ggplot. Here we will define our X and Y variables as well as our aesthetic choices such as our coloring schemes.\nA simple ggplot is shown below.\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp)) +\n  geom_point()\n\n\n\n\nWe can see that we have recreated the plot made using base-R.\nLet’s take it a step further and customize our plot. We can invoke themes\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp)) +\n  geom_point() +\n  theme_bw()\n\n\n\n\nWe can change our axis-labels\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp)) + geom_point() + theme_bw() + labs(x=\"Miles Per Gallon\", y=\"Horsepower\")\n\n\n\n\nWe can change our aesthetics to categorize our data based on the number of cylinders in the engine. It needs to be converted to a factor variable (categorical variable) first.\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp,col=as.factor(cyl))) +\n  geom_point() +\n  theme_bw() +\n  labs(x=\"Miles Per Gallon\", y=\"Horsepower\")\n\n\n\n\nWe can adjust our legend with the labs() command as well.\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp,col=as.factor(cyl))) +\n  geom_point() +\n  theme_bw() +\n  labs(col=\"Cylinders\",x=\"Miles Per Gallon\", y=\"Horsepower\")\n\n\n\n\nIf we want a different graph for each engine type we can use facets.\n\n\nggplot(data=mtcars, aes(x=mpg, y=hp)) +\n  geom_point() +\n  theme_bw() +\n  labs(x=\"Miles Per Gallon\", y=\"Horsepower\") + facet_wrap(~cyl)\n\n\n\n\nThis just scratches the surface of what ggplot is capable of. It is a simple example, but the possibilities are almost endless.\nDifferent Graphic Types\nI have displayed a simple x-y scatter plot, but the process for other plot types is very similar. Here is an example of a highly customized plot. I will use a similar set of data already loaded into R called “mpg”.\n\n\nstr(mpg)\n\n\ntibble [234 × 11] (S3: tbl_df/tbl/data.frame)\n $ manufacturer: chr [1:234] \"audi\" \"audi\" \"audi\" \"audi\" ...\n $ model       : chr [1:234] \"a4\" \"a4\" \"a4\" \"a4\" ...\n $ displ       : num [1:234] 1.8 1.8 2 2 2.8 2.8 3.1 1.8 1.8 2 ...\n $ year        : int [1:234] 1999 1999 2008 2008 1999 1999 2008 1999 1999 2008 ...\n $ cyl         : int [1:234] 4 4 4 4 6 6 6 4 4 4 ...\n $ trans       : chr [1:234] \"auto(l5)\" \"manual(m5)\" \"manual(m6)\" \"auto(av)\" ...\n $ drv         : chr [1:234] \"f\" \"f\" \"f\" \"f\" ...\n $ cty         : int [1:234] 18 21 20 21 16 18 18 18 16 20 ...\n $ hwy         : int [1:234] 29 29 31 30 26 26 27 26 25 28 ...\n $ fl          : chr [1:234] \"p\" \"p\" \"p\" \"p\" ...\n $ class       : chr [1:234] \"compact\" \"compact\" \"compact\" \"compact\" ...\n\nI will create a violin plot which shows the distribution of the data. I am interested in mile per gallon in the city and the number of cylinders in the engine.\n\n\nggplot(data=mpg, aes(x=as.factor(cyl),y=cty)) +\n  geom_violin() +\n  theme_bw() +\n  labs(x=\"Number of Cylinders in Engine\", y=\"Miles per Gallon in the City\")\n\n\n\n\nThis reveals a lot already, but we can add more. Let’s add a box and whisker to better understand the distribution.\n\n\nggplot(data=mpg, aes(x=as.factor(cyl),y=cty)) +\n  geom_violin() +\n  theme_bw() + \n  geom_boxplot(width=0.1) +\n  labs(x=\"Number of Cylinders in Engine\", y=\"Miles per Gallon in the City\")\n\n\n\n\nWe can also add the individual points to this graph. I want to jitter the points to prevent overplotting and make them semi-transparent.\n\n\nggplot(data=mpg, aes(x=as.factor(cyl),y=cty)) +\n  geom_violin() +\n  theme_bw() + \n  geom_boxplot(width=0.1) +\n  geom_jitter(alpha=0.4) +\n  labs(x=\"Number of Cylinders in Engine\", y=\"Miles per Gallon in the City\")\n\n\n\n\nNext I will adjust the width of our jittered points.\n\n\nggplot(data=mpg, aes(x=as.factor(cyl),y=cty)) +\n  geom_violin() +\n  theme_bw() + \n  geom_boxplot(width=0.1) +\n  geom_jitter(alpha=0.3, width=0.2) +\n  labs(x=\"Number of Cylinders in Engine\", y=\"Miles per Gallon in the City\")\n\n\n\n\nWrapping Up\nggplot2 allows us to create powerful and customizable graphics using relatively simple commands. The library is well documented and maintained allowing R novices and experts to quickly pick it up. We have barely scratched the surface of what ggplot2 is able to do. Additionally, user written companion libraries exist which extend the functionality of ggplot2. The possibilities are endless.\n\n\n\n",
    "preview": "posts/R Club November 12/Getting-Started-with-ggplot2_files/figure-html5/unnamed-chunk-4-1.png",
    "last_modified": "2021-11-18T09:36:32-05:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to Rclub Blog",
    "description": "Welcome to the Rclub Blog.",
    "author": [
      {
        "name": "Vince Ramirez",
        "url": {}
      }
    ],
    "date": "2021-11-06",
    "categories": [],
    "contents": "\nIntroducing the R club Blog! A space for us to share everything R!\n\n\n\n",
    "preview": {},
    "last_modified": "2021-11-18T09:36:32-05:00",
    "input_file": {}
  },
  {
    "path": "posts/Writing Function R Club October 11/",
    "title": "R Club - Writing Functions",
    "description": "R Club",
    "author": [],
    "date": "2021-11-06",
    "categories": [],
    "contents": "\nIntroduction\nWords from our sponsors\n\n“Writing good functions is a lifetime journey. Even after using R for many years I still learn new techniques and better ways of approaching old problems.” -Hadley Wickham\n\nOne of the best ways to improve your reach as a data scientist is to write functions. Functions allow you to automate common tasks in a more powerful and general way than copy-and-pasting. Writing a function has three big advantages over using copy-and-paste:\nYou can give a function an evocative name that makes your code easier to understand.\nAs requirements change, you only need to update code in one place, instead of many.\nYou eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).\nOther material\nSource Material for Functions\nhttps://r4ds.had.co.nz/functions.html ## Source Material on Purrr https://dcl-prog.stanford.edu/purrr-parallel.html ## More on Purrr https://r4ds.had.co.nz/iteration.html#the-map-functions ## Purrr Cheatsheat https://github.com/rstudio/cheatsheets/blob/master/purrr.pdf\nCode\nPackages / Functions\n\n\nknitr::opts_chunk$set(echo = TRUE)\n\n# R Version \nR.Version()$version.string #code ran on R version 4.0.5 (2021-03-31)\n\n\n[1] \"R version 4.1.0 (2021-05-18)\"\n\n# Load packages\nif (!require(\"pacman\")) install.packages(\"pacman\")\npacman::p_load(magrittr, scales, tidyverse)\n\nget_data <- function(){\n  df <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10))\n  \n  return(df)\n}\n\n\n\nData Read\n\n\n# Create a table of 10 random number with a mean of zero (SD=1)\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf\n\n\n# A tibble: 10 x 4\n        a       b      c      d\n    <dbl>   <dbl>  <dbl>  <dbl>\n 1  0.973 -0.0730  0.823 -0.151\n 2  0.953 -0.282  -0.729  0.967\n 3  0.425  0.962  -0.611 -0.795\n 4  1.91   0.323  -0.194 -0.205\n 5 -0.741 -0.429  -0.370 -0.616\n 6 -0.245  0.269  -0.509 -0.110\n 7  1.42  -1.38   -0.407 -0.272\n 8  0.868  0.402  -0.148  0.156\n 9 -0.849  1.86    1.83  -1.25 \n10 -0.509  3.54    1.29  -0.378\n\nMaking a function\n\n\n# Rescale data to be between 0 and 1\ndf$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\ndf$b <- (df$b - min(df$b, na.rm = TRUE)) / \n  (max(df$b, na.rm = TRUE) - min(df$a, na.rm = TRUE)) #look a mistake!\ndf$c <- (df$c - min(df$c, na.rm = TRUE)) / \n  (max(df$c, na.rm = TRUE) - min(df$c, na.rm = TRUE))\ndf$d <- (df$d - min(df$d, na.rm = TRUE)) / \n  (max(df$d, na.rm = TRUE) - min(df$d, na.rm = TRUE))\n\ndf # look at column B for the mistake from paste/copy\n\n\n# A tibble: 10 x 4\n        a     b      c     d\n    <dbl> <dbl>  <dbl> <dbl>\n 1 0.660  0.369 0.607  0.495\n 2 0.653  0.310 0      1    \n 3 0.462  0.661 0.0463 0.204\n 4 1      0.481 0.209  0.471\n 5 0.0394 0.268 0.140  0.285\n 6 0.219  0.466 0.0861 0.513\n 7 0.822  0     0.126  0.440\n 8 0.622  0.503 0.227  0.633\n 9 0      0.916 1      0    \n10 0.123  1.39  0.789  0.392\n\n# Reload OG dataframe\ndf <- get_data()\n\n# Ask yourself: Am I repeating code? Am I copy-pasting stuff?\n  ## YES! What am I repeating?\n  df$a <- (df$a - min(df$a, na.rm = TRUE)) / \n  (max(df$a, na.rm = TRUE) - min(df$a, na.rm = TRUE))\n  \n  ## Reload OG dataframe\n  df <- get_data()\n\n  ## Rewrite the code using temporary variables with general names\n  x <- df$a\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n\n\n [1] 0.3798973 0.6395313 0.3916441 0.6788337 0.0000000 0.4547929\n [7] 1.0000000 0.8133605 0.5359254 0.3890551\n\n# Ask yourself: Is there still duplication?\n  ## YES! What am I repeating? [in this case, it's the range]\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n\n\n [1] 0.3798973 0.6395313 0.3916441 0.6788337 0.0000000 0.4547929\n [7] 1.0000000 0.8133605 0.5359254 0.3890551\n\n# Make the function\n  rescale01 <- function(x) {\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n  }\n  \n  ## Check to make sure it works as expected\n  rescale01(c(0, 5, 10))\n\n\n[1] 0.0 0.5 1.0\n\n  ## Add to other customized functions and apply to dataframe\n  df$a <- rescale01(df$a)\n  df$b <- rescale01(df$b)\n  df$c <- rescale01(df$c)\n  df$d <- rescale01(df$d)\n\n\n\nThree things to making a function: 1. You need to pick a name for the function. Here I’ve used rescale01 because this function rescales a vector to lie between 0 and 1. + Function names should be verbs, and arguments should be nouns. + But if the function can be nouns if they represents known nouns (e.g. mean()) or properties of an object (e.g. coef()) + snake_case vs. camelCase - just be consistent + Avoid common function names as your local will have priority\nYou list the inputs, or arguments, to the function inside function. Here we have just one argument. If we had more the call would look like function(x, y, z).\nDefault value have a value set here. eg. rescale01(tmp, Finite = TRUE)\nThere are rules for some names: ++ x,y,z: vectors ++ df: dataframe ++ i,j: numberic indices (typically rows and columns respectively) ++ n: length, number of rows ++ p: number of columns\nYou place the code you have developed in body of the function, a { block that immediately follows function(…).\nstop() is useful to place in conditions if you only accept certain data; if(finite = FALSE){stop(“you can only have finite number here dude”)}\nreturn() another way to break out of a function and return a value\ninvisible() send an object, but don’t print it. Good for keeping things pipeable\nBetter functions\n\n\n# Reload OG dataframe\ndf <- get_data()\n\n# Make our rescale function even better - add default function argument and stop rule\nrescale01 <- function(x, finite=TRUE) {\n  # check for finite numbers in vector\n  if(finite == FALSE){\n    stop(\"you can only have finite number here dude!\")  \n  } \n  \n  #grab range (rng) to use min (rng[1]) and max (rng[2])\n  rng <- range(x, na.rm = TRUE)\n  (x - rng[1]) / (rng[2] - rng[1])\n  \n}\n\n# Call function with attribute\nrescale01(df$a, finite = TRUE)\n\n\n [1] 0.4496844 0.5073375 0.4230537 1.0000000 0.7514802 0.5768766\n [7] 0.3203819 0.0000000 0.3222939 0.2888145\n\n# Pipe Dream - never break the pipe\nshow_missings <- function(df) {\n  n <- sum(is.na(df))\n  cat(\"Missing values: \", n, \"\\n\", sep = \"\")\n  \n  invisible(df)\n}\n\nshow_missings(mtcars) \n\n\nMissing values: 0\n\nmtcars %>% \n  show_missings() %>% \n  mutate(mpg = ifelse(mpg < 20, NA, mpg)) %>% \n  show_missings() \n\n\nMissing values: 0\nMissing values: 18\n\npurrrFect functions\nFaster as they are written in C\nRun multiple columns within the pipe\n\n\n# What if I want to run all cols with a function?\ndf %>%\nmap(rescale01)\n\n\n\n$a\n [1] 0.4496844 0.5073375 0.4230537 1.0000000 0.7514802 0.5768766\n [7] 0.3203819 0.0000000 0.3222939 0.2888145\n\n$b\n [1] 0.2238090 0.1229223 0.0000000 0.5674141 0.2684266 0.3186047\n [7] 1.0000000 0.5474187 0.5649674 0.1791412\n\n$c\n [1] 1.0000000 0.0000000 0.5075496 0.2040886 0.3651896 0.1734424\n [7] 0.1896919 0.2876244 0.6463605 0.4859685\n\n$d\n [1] 0.09331861 0.36398592 0.32631510 0.14670286 0.48385989 0.70930657\n [7] 1.00000000 0.05151067 0.12948621 0.00000000\n\ndf %>%\n  map_dbl(mean)\n\n\n         a          b          c          d \n 0.6881837  0.1634370 -0.2770932 -0.1907347 \n\n# But what about spitting out a vector instead of a list?\ndf %>%\n  map(rescale01) %>% str()\n\n\nList of 4\n $ a: num [1:10] 0.45 0.507 0.423 1 0.751 ...\n $ b: num [1:10] 0.224 0.123 0 0.567 0.268 ...\n $ c: num [1:10] 1 0 0.508 0.204 0.365 ...\n $ d: num [1:10] 0.0933 0.364 0.3263 0.1467 0.4839 ...\n\ndf %>%\n  modify(rescale01)\n\n\n# A tibble: 10 x 4\n       a     b     c      d\n   <dbl> <dbl> <dbl>  <dbl>\n 1 0.450 0.224 1     0.0933\n 2 0.507 0.123 0     0.364 \n 3 0.423 0     0.508 0.326 \n 4 1     0.567 0.204 0.147 \n 5 0.751 0.268 0.365 0.484 \n 6 0.577 0.319 0.173 0.709 \n 7 0.320 1     0.190 1     \n 8 0     0.547 0.288 0.0515\n 9 0.322 0.565 0.646 0.129 \n10 0.289 0.179 0.486 0     \n\n# What if I want to run a few cols with function?\ndf %>%\n  modify_at(c(\"a\", \"b\"), rescale01)\n\n\n# A tibble: 10 x 4\n       a     b      c      d\n   <dbl> <dbl>  <dbl>  <dbl>\n 1 0.450 0.224  2.18  -0.739\n 2 0.507 0.123 -1.82  -0.113\n 3 0.423 0      0.210 -0.200\n 4 1     0.567 -1.01  -0.616\n 5 0.751 0.268 -0.360  0.164\n 6 0.577 0.319 -1.13   0.685\n 7 0.320 1     -1.06   1.36 \n 8 0     0.547 -0.671 -0.836\n 9 0.322 0.565  0.765 -0.655\n10 0.289 0.179  0.123 -0.955\n\ndf %>%\n  mutate_at(c(\"a\", \"b\"), ~ rescale01(.))\n\n\n# A tibble: 10 x 4\n       a     b      c      d\n   <dbl> <dbl>  <dbl>  <dbl>\n 1 0.450 0.224  2.18  -0.739\n 2 0.507 0.123 -1.82  -0.113\n 3 0.423 0      0.210 -0.200\n 4 1     0.567 -1.01  -0.616\n 5 0.751 0.268 -0.360  0.164\n 6 0.577 0.319 -1.13   0.685\n 7 0.320 1     -1.06   1.36 \n 8 0     0.547 -0.671 -0.836\n 9 0.322 0.565  0.765 -0.655\n10 0.289 0.179  0.123 -0.955\n\ndf2 <- df\n\n\n# What if we're only going to run a function once? Answer: Anonymous functions\ndf %>%\n  modify(function(x) x+2)\n\n\n# A tibble: 10 x 4\n       a     b     c     d\n   <dbl> <dbl> <dbl> <dbl>\n 1  2.64  1.71 4.18   1.26\n 2  2.83  1.42 0.178  1.89\n 3  2.56  1.06 2.21   1.80\n 4  4.43  2.71 0.995  1.38\n 5  3.62  1.84 1.64   2.16\n 6  3.05  1.99 0.872  2.69\n 7  2.22  3.96 0.937  3.36\n 8  1.18  2.65 1.33   1.16\n 9  2.23  2.70 2.77   1.34\n10  2.12  1.58 2.12   1.05\n\n#shortcuts from purrr\ndf %>%\n  modify(~ . + 2)\n\n\n# A tibble: 10 x 4\n       a     b     c     d\n   <dbl> <dbl> <dbl> <dbl>\n 1  2.64  1.71 4.18   1.26\n 2  2.83  1.42 0.178  1.89\n 3  2.56  1.06 2.21   1.80\n 4  4.43  2.71 0.995  1.38\n 5  3.62  1.84 1.64   2.16\n 6  3.05  1.99 0.872  2.69\n 7  2.22  3.96 0.937  3.36\n 8  1.18  2.65 1.33   1.16\n 9  2.23  2.70 2.77   1.34\n10  2.12  1.58 2.12   1.05\n\n# So why are maps powerful with functions. Answer: pipe stuff\ndf %>% \n  mutate(e = c(rep(\"dude\", 5), rep(\"sweet\", 5))) %>%\n  split(.$e) %>%\n  map(~ lm(a ~ b, data =.)) %>%\n  map(summary) %>%\n  map_dbl(\"r.squared\")\n\n\n      dude      sweet \n0.84405175 0.03733455 \n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-11-18T09:36:32-05:00",
    "input_file": {}
  }
]
